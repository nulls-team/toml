# TOML-совместимый формат: описание синтаксиса и примеры

Этот документ описывает синтаксис формата, основанного
на [ABNF-описании](https://github.com/toml-lang/toml/blob/main/toml.abnf) из репозитория
TOML. Формат ориентирован на удобное для человека структурирование данных, поддерживает
Unicode, ключ-значение структуры, вложенные таблицы, массивы и inline-таблицы.

Важно! TOML — формат, чувствительный к регистру, а значит переменные `key` и `Key` в нём
совершенно разные. То же влияет и на тип boolean, который может принимать только
значения `true` и `false` и не может быть записан в другом регистре.

## Общая структура

Файл представляет собой последовательность выражений (expression), разделённых
переносами строки. Каждое выражение — это либо пустая строка, комментарий, строка с
парой ключ-значение, либо определение таблицы.

```toml
# Комментарий
key = "value"

[table]
```

## Комментарии

Комментарии начинаются с символа `#` и продолжаются до конца строки.

**Пример использования:**

```toml
# Это комментарий
key = 123 # комментарий в конце строки

# Это — многострочный
# комментарий
```

**Не рекомендуется:**

```toml
key = 123 #самый обычный комментарий
#          ^ допустимо, но если после `#` в комментарии нет пробела, может нарушить читаемость
```

## Ключи и значения

Ключи могут быть:

- стандартными (латинские буквы, цифры, подчёркивания, дефисы, некоторые символы
  Unicode),
- заключёнными в кавычки (полная поддержка Unicode),
- составными (через точку, может комбинировать и стандартные, и заключенные в кавычки
  строки).

```toml
name = "Tom"
"ключ с пробелом" = true
user.id = 123
```

Значения могут принимать типы:

- строки (все типы),
- целые числа,
- числа с плавающей точкой,
- булевы значения (`true`, `false`),
- дата/время (формата RFC 3339),
- массивы значений, в том числе с разным типом,
- inline-таблицы.

## Строки

### Обычные строки:

```toml
key = "самая обычная строка"
key-escaped = "строка с \"экранированием\""
```

Экранирование — это механизм, который сообщает парсеру, что следующий символ за `\`
должен восприниматься иначе, как, например, кавычки, которые обычно воспринимаются как
начало или коней строкового значения.

Для удобства введены следующие escape-последовательности:

```
\b         - backspace       (U+0008)
\t         - tab             (U+0009)
\n         - linefeed        (U+000A)
\f         - form feed       (U+000C)
\r         - carriage return (U+000D)
\"         - quote           (U+0022)
\\         - backslash       (U+005C)
\uXXXX     - unicode         (U+XXXX)
\UXXXXXXXX - unicode         (U+XXXXXXXX)
```

Выдержка из спецификации:

> Any Unicode character may be escaped with the \uXXXX or \UXXXXXXXX forms. The escape
> codes must be valid Unicode scalar values.

Все остальные escape-последовательности, которые не перечислены в списке выше —
зарезервированы. При их использовании парсер TOML должен выдать ошибку.

### Многострочные строки:

```toml
text = """Это —
многострочная
строка"""
fake_multiline = """
На самом деле \

эта строка \



не содержит \
переносов"""
```

Обратите внимание на значение с ключом `fake_multiline`. Строка не врёт: по
спецификациям TOML, если знак `\` является последнем в строчке, то многострочная строка
парсится до следующего не-пробельного (non-whitespace) значения. А перенос строки после
открывающей кавычки опускается.

В ОС Windows для объявления путей используется обратный слэш `\`. Из-за этого в обычной
и многострочной строках путь не получится использовать без изменений — символы `\` в нём
нужно будет экранировать. Иначе путь будет невалидным. Эту проблему призваны решить
литеральные строки.

### Литеральные строки:

```toml
path = 'C:\Windows\Path'
```

Для достижения поставленных целей, в литеральных строках не используется механизм
экранирования. То есть во всех случаях использования символа `\`, он будет воспринят
именно как `\`.

Если вам необходимо экранирование, то вам следует использовать обычные или многострочные
строки вместо литеральных.

### Многострочные литеральные строки:

```toml
sql = '''SELECT * FROM table
WHERE id = 42'''
sql2 = '''
SELECT * FROM table
WHERE id = 42'''
```

Согласно спецификации, перенос строки, следующий за открывающими кавычками,
отбрасывается. То есть значения по ключам `sql` и `sql2` равны в точности до байта.

## Числа

Поддерживаются десятичные, шестнадцатеричные, восьмеричные и двоичные:

```toml
dec = 1234
hex = 0xDEADBEEF
oct = 0o755
bin = 0b110101
```

Для удобного представления больших чисел можно использовать символ подчёркивания `_`
между цифрами.

**Пример использования:**

```toml
big_dec = 1_000
big_hex = 0xDEAD_BEEF
big_bin = 0b1111_1111
some_millions = 5_349_221
indian_number = 53_49_221  # Indian number system grouping
```

**Не рекомендуется:**

```toml
discouraged = 1_2_3_4_5
#              ^ ^ ^ ^
# Значения разделён без какой-либо цели
```

Важно помнить для чего создан символ разделения цифр и стараться использовать его только
в самых нужных ситуациях.

**Пример неправильного использования:**

```toml
delimiter_prefix = 0x_1234
delimiter_postfix = 0b1001_
```

Символ разделения нельзя использовать сразу после префикса числа или в конце числа.
Обязательным условием использования разделителя является наличие цифры до и после.

## Числа с плавающей точкой и специальные значения

```toml
# fractional
float1 = +1.0
float2 = 3.1415
float3 = -0.01

# exponent
float4 = 5e+22
float5 = 1e06
float6 = -2E-2

# both
flt7 = 6.626e-34
```

**Специальные значения:**

```toml
pos_inf = inf
pos_inf2 = +inf
neg_inf = -inf
nan = nan

# infinity
sf1 = inf  # positive infinity
sf2 = +inf # positive infinity
sf3 = -inf # negative infinity

# not a number
sf4 = nan  # actual sNaN/qNaN encoding is implementation-specific
sf5 = +nan # same as `nan`
sf6 = -nan # valid, actual encoding is implementation-specific
```

Специальные значения `inf` и `nan` не могут быть записан в другом регистре.

Важно заметить, что формат не резервирует никакие слова для ключей, а значит,
строка `nan = nan` не противоречит спецификации формата, однако является двусмысленной.

**Пример неправильного использования:**

```toml
zero = .0
one = 1.
invalid_float_3 = 3.e+20
```

Если десятичный разделитель (точка) используется, то с каждой стороны должно быть хотя
бы одна цифра.

## Логические значения

```toml
is_valid = true
is_enabled = false
```

Логические, или Булевы, значения могут принимать только значения `true` и `false` и не
могут быть записан в другом регистре: `True`, `False`, `fAlSe`, `TRUE` — должны выдать
ошибку парсинга.

## Дата и время

```toml
dob = 1979-05-27T07:32:00Z
due = 2025-01-01T12:00:00+03:00
due2 = 2025-01-01 12:00:00+03:00
day = 2025-04-09
hour = 12:30:45
```

## Массивы

Массивы задаются в квадратных скобках. Все элементы должны быть одного типа.

```toml
numbers = [1, 2, 3]
strings = ["a", "b", "c"]
nested = [[1, 2], [3, 4]]

# Mixed-type arrays are allowed
numbers = [0.1, 0.2, 0.5, 1, 2, 5]
contributors = [
    "Foo Bar <foo@example.com>",
    { name = "Baz Qux", email = "bazqux@example.com", url = "https://example.com/bazqux" }
]

integers2 = [
    1, 2, 3
]

integers3 = [
    1,
    2, # this is ok
]
```

После разделителя значений в массивах (запятых) следует ставить пробелы или переносы строк.

**Пример неправильного использования:**

```toml
integers3 = [
    1, ,,
]
```

## Таблицы

Таблицы именуются по таким же правилам, как и ключи.

### Обычные таблицы

```toml
[owner]
name = "Tom"
dob = 1979-05-27T07:32:00Z
```

### Вложенные таблицы через составные ключи

```toml
[database]
[database.connection]
user = "admin"
password = "secret"
```

или

```toml
database.connection.user = "admin"
database.connection.password = "secret"
```

При этом следует заметить, что указание `[database]` излишне, так как согласно
спецификации парсер TOML обязан создавать родительские таблицы сам при использовании
составных ключей в квадратных скобках.

## Inline-таблицы

Inline-таблицы — это структуры содержащие пары ключ-значение в одной строке:

```toml
point = { x = 1, y = 2 }
```

**Важно:**

- Inline-таблицы не поддерживают вложенные таблицы.
- Не допускается перенос строки, кроме использования многострочных строк (не
  рекомендуется).
- Не допускается использование trailing comma (завершающей запятой).
- Не допускаются комментарии внутри.

### Таблицы-массивы (array of tables)

Таблицы-массивы следует использовать для описания списка однотипных объектов:

```toml
[[product]]
name = "Book"
price = 12.5

[[product]]
name = "Pen"
price = 1.2
```

Массив inline-таблиц задаётся следующим образом:

```toml
points = [{ x = 1, y = 2, z = 3 },
    { x = 7, y = 8, z = 9 },
    { x = 2, y = 4, z = 8 }]
```

**Пример неправильного использования:**

```toml
[[product]]
name = "Notebook"

[product]
name = "Conflict"
```

Нельзя определять массив таблиц и обычную таблицу с одинаковыми именами.
